# 烘焙概述(Baking overview)

烘焙是一个将 Unity 编辑器中的 GameObject 数据（创作数据）转换为实体场景中的实体（运行时数据）的过程。烘焙是一个不可逆的过程，它将性能密集但灵活的一组 GameObjects 转换为优化性能的一组实体和组件。

### 创作数据和运行时数据

在 Unity 中，GameObject 数据由运行时数据和创作数据组成。这种数据模型在编辑过程中提供了很大的灵活性，但在运行时并不需要这些灵活性。因为 Unity 同时处理 GameObject 的运行时数据和创作数据，这意味着运行时性能会受到影响。

然而，Unity 的实体组件系统 (ECS) 设计旨在以最有效的方式表示应用程序中的数据，以避免处理任何不必要的数据。因此，它将创作数据和运行时数据分开：

* **创作数据**：在编辑应用程序时创建的任何数据，例如脚本、资源或其他游戏相关数据。这种数据类型是灵活且可读的，旨在供人类交互使用。
* **运行时数据**：ECS 在运行时处理的数据，例如你进入播放模式时处理的数据。这种数据类型经过性能和存储效率优化，旨在供计算机处理。

在编辑器中，你可以通过检查面板和层级视图顶部的数据模式圆圈来查看 Unity 正在处理的数据类型。有关更多信息，请参阅[使用创作和运行时数据](https://docs.unity3d.com/Manual/index.html)文档。

### 烘焙过程

代表创作数据的 GameObjects 称为创作 GameObjects。作为创作 GameObject 一部分的任何组件称为创作组件，以区分它们与 ECS 组件。

创作 GameObjects 存在于创作场景中，Unity 用它来将该场景内的 GameObject 数据转换为 ECS 数据。将创作 GameObjects 数据转换为 ECS 数据的过程称为烘焙。有关创作场景的更多信息，请参阅[场景概述](https://docs.unity3d.com/Manual/SceneWorkflow.html)文档。

烘焙只在编辑器中进行，游戏中不会进行，就像资产导入一样。因为处理包含烘焙代码的 GameObject 表示及其数据需要大量时间和处理能力，所以只在编辑器中进行烘焙。在游戏中执行烘焙会降低应用程序的性能。

每当创作场景中的创作数据发生变化时，它都会触发烘焙过程。Unity 如何烘焙数据取决于你是否将创作场景作为子场景打开。

#### 打开的子场景

如果相应的创作场景的子场景是打开的，那么它会触发实时烘焙。实时烘焙是在你工作时，将创作数据烘焙为 ECS 数据。根据 Unity 需要处理的创作数据量，它要么增量烘焙数据，要么对数据进行完整烘焙：

* **完整烘焙**：Unity 处理整个场景并进行烘焙。
* **增量烘焙**：Unity 仅烘焙已修改的数据。

#### 关闭的子场景

如果相应的创作场景的子场景是关闭的，则 Unity 会在后台执行异步烘焙。它会对创作场景中的数据进行完整烘焙。

**完整烘焙**

当导入整个场景时，Unity 会执行完整烘焙过程。当请求加载实体场景并且引用它的子场景处于关闭状态时，导入一个完整的场景会在后台资产导入器进程中发生。

后台资产导入器是一个无 GUI 的编辑器进程。当场景需要烘焙时，编辑器按需启动它，并且它异步运行。这种方法的优点是主要的编辑器在烘焙过程中仍然可用。然而，这意味着当你初次加载实体场景时，可能需要几秒钟才能在编辑器中出现。主场景的后续加载会重用已经烘焙的实体场景，因此会更快。

只有在需要加载 ECS 数据而不是 GameObject 创作数据时才会进行完整烘焙。这种情况发生在以下几种情况：

* 实体场景丢失（磁盘上不存在）。
* 创作场景已被修改且实体场景已过期。
* 烘焙代码所在的程序集没有包含单个 `[BakingVersion]` 属性。这意味着程序集已被修改，实体场景已过期。
* 烘焙代码上的 `[BakingVersion]` 属性已被修改。
* 实体项目设置已被修改。
* 从子场景检查器请求重新导入。此功能用于故障排除。
* 在编辑器首选项中清除烘焙缓存。

完整烘焙的输出是一组磁盘上的文件。编辑器或你的应用程序随后加载这些文件。因此，只有在需要时才会进行烘焙。

**增量烘焙**

当子场景加载创作场景时，它也会初始化增量烘焙。对场景执行增量烘焙意味着你可以在编辑创作场景时直接访问烘焙结果。

在增量烘焙过程中，烘焙在内存中发生，而不是回写到磁盘。当你更改创作 GameObjects 的内容时，Unity 只重新烘焙受影响的实体和组件。仅烘焙数据的一个小子集要快得多，而且意味着 ECS 数据可以实时更新。这实际上给出了直接编辑 ECS 数据的印象，即使烘焙在持续进行。

增量烘焙带来了一些额外的复杂性。虽然完整烘焙总是从空白开始并系统地烘焙所有内容，但增量烘焙总是在先前的烘焙过程中基础上运行，并且仅烘焙依赖于已更改的创作 GameObjects 的实体。

这意味着在对其进行更改时，完整场景烘焙和增量烘焙之间可能存在差异。在编写烘焙代码时，必须确保结果保持一致。

> **注意**： 增量烘焙和完整烘焙之间的输出存在差异。实体的排序不同，实体的大小也不同。因此，块布局不是相同的。必须确保这不会影响应用程序的用户体验。
