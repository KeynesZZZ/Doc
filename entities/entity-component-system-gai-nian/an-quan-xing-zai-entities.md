# 安全性在 Entities

&#x20;Entities 包提供了一个框架和一组 API，以便您可以使用面向数据的设计原则高效地转换数据。这涉及利用 Burst 编译器和本机互操作尽可能直接访问数据。这种方法有时会违背 C# 语言内置的安全机制。

许多 Entities 包的内部 API 使用不安全代码块和原始指针来获取最佳性能。一些 API 返回的数据引用可能超过被引用数据的生命周期。本页面包含有关如何在 Entities 中处理安全问题的信息以及可能遇到的一些陷阱。

#### 有防护的安全违规

在大多数情况下，Entities 框架及其支持包尝试在编辑器中和启用安全检查时防止安全问题。在这些情况下发生的安全错误应该抛出有效错误，提供修复信息并防止编辑器崩溃。然而，在运行时构建中无法保证这些情况不会导致崩溃或内存损坏。您也可以通过作业中的安全检查设置（Jobs > Burst > Safety Checks）禁用一些安全检查。有关更多信息，请参阅数据访问错误文档。

#### 结构性变化

Entities 中最常见的安全问题之一是结构性变化使数据无效化。这是因为结构性变化修改实体的原型，使实体移动到另一个 chunk。

> **注意**: 启用和禁用可启用组件不是结构性变化。但是，所有启用或禁用组件的作业必须完成，然后才能检查启用状态，以确保对组件启用状态的所有更改已完成。

Entities API 将数据存储在 chunks 中，通常通过作业系统或主线程访问。作业系统通常处理传递给 `NativeContainers` 的数据的所有安全性，并使用注释标记是读取、写入还是同时进行这两者。然而，任何导致结构性变化的 API 可能会使数据在内存中移动并使对该数据的任何引用失效。

#### ExclusiveEntityTransaction

一般来说，所有结构性变化必须在主线程上使用世界的 `EntityManager` 进行。`ExclusiveEntityTransaction` 功能允许您将 `EntityManager` 暂时置于一种模式，在这种模式下单个工作线程（运行 `IJob`）可以安全地对该世界的实体执行结构性变化操作，使主线程可以自由地执行其他工作。

此功能的主要动机是允许次级/流世界安全地修改其实体并进行结构性变化，而不会阻碍主线程处理默认世界中的实体。它并不是为了作为从工作线程调用 `EntityManager` 功能的通用接口。某些 `EntityManager` 操作依赖于仅在主线程上的功能，因此如果从作业代码中调用将无法正常工作。只有 `ExclusiveEntityTransaction` 直接暴露的操作子集才正式支持。

#### RefRW/RefRO

Entities 包含显式引用类型，您可以使用这些类型将包含的类型标记为读写（`RefRW`）或只读（`RefRO`）。这些引用类型具有检查，以确保在启用安全检查时包含的类型仍然有效。结构性变化可能会导致包含的类型不再有效。

#### 无防护的安全违规

存在一些未防护的情况。本节概述了由于 Entities API 在编辑器中可能发生的崩溃或内存损坏的情况。

**IJobEntity**

`IJobEntity` 允许您使用外部 `EntityQuery` 调度作业。这使用 `EntityQuery` 检索实体，然后使用这些实体执行 `IJobEntity` 的 `Execute` 方法。ECS 不会检查实体是否确实具有组件参数，因此您必须确保它们保持同步。如果 `Execute` 参数与查询的组件不匹配，这可能导致崩溃或内存损坏。

**InternalCompilerInterface**

`InternalCompilerInterface` 静态类包含一些方法，这些方法将一些 DOTS 内部暴露给源生成的代码。这是必要的，因为生成的代码通常只能调用公共 API。

> **警告**: 不要使用 `InternalCompilerInterface` 中包含的 API。它们仅在从生成的代码调用时上下文中使用，并且在未来可能会发生变化。
