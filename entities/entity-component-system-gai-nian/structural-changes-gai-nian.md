# Structural changes 概念

导致 Unity 重新组织内存块或调整内存中块内容的操作称为结构性变化。了解哪些操作是结构性变化很重要，因为它们可能资源密集型，并且只能在主线程上执行；不能在作业中执行。

以下操作被视为结构性变化：

* 创建或销毁实体。
* 添加或移除组件。
* 设置共享组件值。

#### 创建实体

当你创建一个实体时，Unity 要么将该实体添加到现有 chunk，要么如果没有适合该实体原型的 chunk，则创建一个新的 chunk 并将实体添加到其中。

#### 销毁实体

当你销毁一个实体时，Unity 会从其 chunk 中移除该实体。如果移除实体在 chunk 中留下空隙，Unity 会将 chunk 中最后一个实体移动以填补空缺。如果移除实体使 chunk 为空，Unity 会解除分配该 chunk。

#### 添加或移除组件

当你向实体添加或移除组件时，你改变了实体的原型。Unity 将每个实体存储在与其原型匹配的 chunk 中。这意味着如果你更改实体的原型，Unity 必须将实体移动到另一个 chunk。如果没有合适的 chunk，Unity 会创建一个新的。如果移动后之前的 chunk 留下了空隙或为空，Unity 分别会移动 chunk 中的最后一个实体填补空隙或解除分配该 chunk。

#### 设置共享组件值

当你设置实体的共享组件值时，Unity 会将实体移动到与新共享组件值匹配的 chunk。如果没有合适的 chunk，Unity 会创建一个新的。如果移动后之前的 chunk 留下空隙或为空，Unity 分别会移动 chunk 中的最后一个实体填补空隙或解除分配该 chunk。

> **注意**: 设置常规组件值不是结构性变化，因为这不需要 Unity 移动实体。

#### 同步点

你不能在作业中直接进行结构性变化，因为这可能会使已调度的其他作业失效，并创建同步点。

同步点是程序执行中的一个点，它等待所有已调度作业完成。同步点限制了一段时间内使用作业系统中所有工作线程的能力。因此，应尽量避免同步点。ECS 数据的结构性变化是同步点的主要原因。

结构性变化不仅需要同步点，还会使对任何组件数据的所有直接引用无效。这包括 `DynamicBuffer` 实例和提供组件直接访问的方法（如 `ComponentSystemBase.GetComponentDataFromEntity`）的结果。

#### 避免同步点

你可以使用实体命令缓冲区来排队结构性变化，而不是立即执行它们。可以在帧的稍后时间播放存储在实体命令缓冲区中的命令。这将多个分散在帧内的同步点减少到一个同步点。

每个标准 `ComponentSystemGroup` 实例提供一个 `EntityCommandBufferSystem` 作为组中第一个和最后一个更新的系统。如果从这些标准系统之一获取实体命令缓冲区对象，则所有结构性变化都发生在帧中的同一点，这会产生一个同步点。你还可以使用实体命令缓冲区在作业中记录结构性变化，而不仅仅是在主线程上进行结构性变化。

如果不能为任务使用实体命令缓冲区，请将任何进行结构性变化的系统在系统执行顺序中分组。两个都进行结构性变化的系统只有在顺序更新时才会创建一个同步点。
