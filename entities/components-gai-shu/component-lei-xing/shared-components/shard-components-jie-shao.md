# Shard Components介绍



共享组件根据其共享组件的值将实体分组在区块中，这有助于数据的去重。为此，Unity 将具有相同共享组件值的一个原型的所有实体存储在一起。这消除了跨实体的重复值。

你可以创建托管和非托管共享组件。托管共享组件具有与常规托管组件相同的优点和限制。

### 共享组件值存储

对于每个世界，Unity 将共享组件值存储在独立于 ECS 区块的数组中，并且该世界中的区块存储句柄以定位它们原型的适当共享组件值。同一区块中的实体共享相同的共享组件值。多个区块可以存储相同的共享组件句柄，这意味着使用相同共享组件值的实体数量没有限制。

如果你更改实体的共享组件值，Unity 会将该实体移动到使用新共享组件值的区块。这意味着更改实体的共享组件值是结构性变化。如果共享组件值数组中已经存在等值，Unity 会将实体移动到存储现有值索引的区块。否则，Unity 会将新值添加到共享组件值数组中，并将实体移动到存储此新值索引的新区块。有关如何更改 ECS 比较共享组件值的方法的信息，请参阅覆盖默认比较行为。

Unity 分别存储非托管和托管共享组件，并通过非托管共享组件 API（例如 `SetUnmanagedSharedComponentData`）使非托管共享组件可用于 Burst 编译的代码。更多信息请参阅优化共享组件。

### 覆盖默认比较行为

要更改 ECS 比较共享组件实例的方法，请为共享组件实现 `IEquatable<YourSharedComponent>`。如果这样做，ECS 会使用你的实现来检查共享组件实例是否相等。如果共享组件是非托管的，可以将 `[BurstCompile]` 属性添加到共享组件结构体、`Equals` 方法和 `GetHashCode` 方法，以提高性能。

### 在世界之间共享共享组件

对于创建和维持成本高的托管对象（如 blob 资产），你可以使用共享组件在所有世界中只存储该对象的一份副本。为此，请通过 `Retain` 和 `Release` 实现 `IRefCounted` 接口。实现 `Retain` 和 `Release` 以便这些方法正确管理基础资源的生命周期。如果共享组件是非托管的，可以将 `[BurstCompile]` 属性添加到共享组件结构体、`Retain` 方法和 `Release` 方法，以提高性能。

### 不要修改共享组件引用的对象

为了正常工作，共享组件依赖于你使用 Entities API 来改变它们的值。这包括引用的对象。如果共享组件包含引用类型或指针，请小心不要在不使用 Entities API 的情况下修改引用的对象。
