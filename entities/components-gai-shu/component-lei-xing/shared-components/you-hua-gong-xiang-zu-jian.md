# 优化共享组件

共享组件与其他组件类型有不同的性能考虑。本页描述了共享组件特定的性能考虑和优化技术。

### 使用非托管共享组件

如果可能，请优先使用非托管共享组件而不是托管共享组件。这是因为 Unity 将非托管共享组件存储在通过非托管共享组件 API（如 `SetUnmanagedSharedComponentData`）可访问的地方，这为 Burst 编译的代码提供了性能优势。

### 避免频繁更新

更新实体的共享组件值是一种结构性变化，这意味着 Unity 会将实体移动到另一个区块。出于性能原因，尽量避免频繁执行此操作。

### 避免大量唯一的共享组件值

所有位于同一区块的实体必须共享相同的共享组件值。这意味着如果你为大量实体赋予唯一的共享组件值，它们会分散在许多几乎为空的区块中。

例如，如果一个原型有 500 个实体，并且每个实体都有一个唯一的共享组件值，Unity 会将每个实体存储在一个单独的区块中。这浪费了每个区块的大部分空间，并且意味着要遍历该原型的所有实体，Unity 必须遍历所有 500 个区块。这抵消了 ECS 区块布局的好处并降低了性能。为避免这个问题，尽量使用尽可能少的唯一共享组件值。如果这 500 个示例实体仅共享十个唯一的共享组件值，Unity 可以将它们存储在最多十个区块中。

对于具有多个共享组件类型的原型需要谨慎。一个原型区块中的所有实体必须具有相同组合的共享组件值，因此具有多个共享组件类型的原型容易出现碎片化。

### 注意事项

要检查区块碎片化情况，你可以在 Archetypes 窗口查看区块利用率。





ChatCPT 回答

## 优化共享组件的建议

为了提高共享组件的性能，请考虑以下几点：

1. **使用非托管共享组件**：
   * 尽量使用非托管共享组件而不是托管共享组件，因为它们可以通过 Burst 编译代码访问，从而提升性能。
2. **避免频繁更新共享组件值**：
   * 更新共享组件值会导致实体在区块之间移动，这是一个昂贵的操作。尽量减少对共享组件值的频繁更新，以保持良好的性能。
3. **最小化唯一共享组件值的数量**：
   * 避免为大量实体设置唯一的共享组件值。这会导致空闲区块的浪费和性能下降。尽量将多个实体分组到一起，共享相同的组件值。
4. **优化具有多个共享组件类型的原型**：
   * 如果一个原型包含多个共享组件类型，确保这些组件值组合不会导致过多的碎片化。适当地设计共享组件值以减少区块分散。
5. **监控区块利用率**：
   * 使用 Archetypes 窗口查看区块利用率，识别并解决碎片化问题。高效的区块利用率有助于增强性能。
6. **实现自定义比较方法**：
   * 对于托管共享组件，实现 `IEquatable<>` 接口和 `GetHashCode` 方法，可以避免由于隐式装箱带来的性能开销。
7. **慎重管理外部资源**：
   * 对于引用外部资源（如粒子系统）的共享组件，确保正确管理其生命周期，避免资源泄露和不必要的重复创建。

### 示例代码

#### 非托管理共享组件

```csharp
public struct ExampleUnmanagedSharedComponent : ISharedComponentData
{
    public int Value;
}


```

托管理共享组件

```csharp

public struct ExampleManagedSharedComponent : ISharedComponentData, IEquatable<ExampleManagedSharedComponent>
{
    public string Value;

    public bool Equals(ExampleManagedSharedComponent other)
    {
        return Value.Equals(other.Value);
    }

    public override int GetHashCode()
    {
        return Value.GetHashCode();
    }
}
```
