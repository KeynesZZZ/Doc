# Introducing dynamic buffer components

动态缓冲组件是作为非托管结构体的可调整大小数组的组件。你可以用它来存储实体的数组数据，例如实体需要导航的路径点位置。

除了数据之外，每个缓冲区还存储长度 (Length)、容量 (Capacity) 和一个内部指针：

* 长度 (Length) 是缓冲区中的元素数量。它从 0 开始，当你向缓冲区添加值时递增。
* 容量 (Capacity) 是缓冲区中的存储量。它一开始匹配内部缓冲区容量。设置容量会调整缓冲区的大小。
* 指针 (Pointer) 指示动态缓冲数据的位置。最初它为 null，表示数据与实体在同一块中，如果 Unity 将数据移到块外，则指针将指向新数组。有关 Unity 如何存储动态缓冲组件的更多信息，请参阅容量 (Capacity)。

### 容量 (Capacity)

动态缓冲区的初始容量由缓冲区存储的类型定义。默认情况下，容量默认为可以容纳在128字节内的元素数量。有关详细信息，请参阅 `DefaultBufferCapacityNumerator`。你可以使用 `InternalBufferCapacity` 属性指定自定义容量。有关如何创建动态缓冲组件类型的信息，请参阅创建动态缓冲组件类型。

最初，Unity 将动态缓冲数据直接存储在该组件所属实体的块中。如果动态缓冲区的长度超过了容量，Unity 会将动态缓冲数据复制到块外的数组中。如果动态缓冲区的长度后来缩小到小于容量，Unity 仍然会将数据存储在块外；如果 Unity 将动态缓冲数据移出块，它不会再将数据移回块中。

原始内部缓冲容量是块的一部分，Unity 只有在释放块本身时才会释放它。这意味着如果动态缓冲长度超过了内部容量，并且 Unity 将数据复制到块外，则块内会有浪费的空间。因此，最佳实践是在可能的情况下使用块中的数据。为此，请确保大多数实体不超出缓冲容量，但也不要设置过高的容量，如果实体不使用它。如果动态缓冲区的大小变化太大，最佳实践是将其数据存储在块外。为此，请将 `InternalBufferCapacity` 设置为0。

还有其他选项可用来存储数组数据：

* **Blob 资产**：存储紧密打包的只读结构化数据，包括数组，并且多个实体可以共享单个 Blob 资产。由于它们是只读的，你可以同时从多个线程访问它们。
* **托管组件**：存储原生或托管对象的数组。然而，访问托管组件数据比动态缓冲组件数据更受限制且性能较低。此外，你需要手动克隆和处理数组数据。
* **共享组件**：类似于托管组件，它们存储原生或托管对象的数组，你的实体可以存储这些较大数组的索引。它们具有与托管组件相同的限制和性能考虑因素。

### 结构变化 (Structural changes)

结构变化可能会破坏或移动动态缓冲区引用的数组，这意味着在结构变化之后，任何对动态缓冲区的句柄都会失效。你必须在任何结构变化之后重新获取动态缓冲区。例如：

```csharp
public void DynamicBufferExample(Entity e)
{
    // 获取类型为 MyElement 的动态缓冲区。
    DynamicBuffer<MyElement> myBuff = EntityManager.GetBuffer<MyElement>(e);

    // 这个结构变化使先前获取的 DynamicBuffer 无效。
    EntityManager.CreateEntity();

    // 安全检查将在对缓冲区的任何读写操作上抛出异常。
    var x = myBuff[0];

    // 在上述结构变化之后重新获取动态缓冲区。
    myBuff = EntityManager.GetBuffer<MyElement>(e);
    var y = myBuff[0];
}
```

在进行结构变化后，需要重新获取动态缓冲区，以确保其数据引用仍然有效。

### 与组件中原生容器的比较 (Comparison to native containers in components)

动态缓冲区通常比在组件中使用原生容器更可取，因为它们没有后者的作业调度限制，并且可以选择内联存储在块内，这有助于减少内存带宽的使用。

一般来说，当有多个实体需要一个集合时，可能值得使用动态缓冲区。如果只有一个实体，需要的集合可能作为内含原生容器的单例来工作效果更好。
